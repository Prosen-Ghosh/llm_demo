# Vulnerability Search

![Demo GIF](./docs/app_demo.gif)

This project is a semantic search engine for a CVE (Common Vulnerabilities and Exposures) database. It uses a Streamlit web interface to provide a user-friendly way to search for vulnerabilities using natural language.

## üöÄ Getting Started

1.  **Clone & Setup**: Create a virtual environment and install dependencies using `pip install -r requirements.txt`.
2.  **Fetch Data**: Run `python main.py` to download the latest CVE data.
3.  **Run the App**: Execute `streamlit run app.py` to start the application.

## How it Works (Architecture)

The application operates in two main phases: indexing and searching.

### 1. Indexing (Handled by `main.py`)

- The `CVEDataLoader` in `src/data_loader.py` fetches vulnerability data from the NVD (National Vulnerability Database) API.
- The `EmbeddingEngine` in `src/embedding_engine.py` processes each CVE's text and metadata, converting it into a rich document string. It then uses the `all-MiniLM-L6-v2` sentence-transformer model to create a vector embedding from this string.
- The `ChromaManager` in `src/chroma_manager.py` takes these embeddings, along with their metadata (like CVSS score, severity, etc.), and stores them in an in-memory ChromaDB vector database collection.
- The fetched data is saved to `data/cve_data.json`.

### 2. Searching (Handled by `app.py`)

- When the Streamlit app starts, the `initialize_search_engine` function (cached for performance) loads the data from `data/cve_data.json` and populates the ChromaDB database, similar to the indexing step.
- The user enters a natural language query (e.g., 'remote code execution in web servers') into the Streamlit UI.
- The `VulnerabilitySearch` class in `src/search_interface.py` orchestrates the search. It takes the user's query and uses the `EmbeddingEngine` to create a query vector.
- It builds a metadata filter based on the user's selections (e.g., Severity, CVSS score).
- It uses the `ChromaManager` to perform a similarity search on the vector database, finding the CVEs with embeddings closest to the query's embedding, while respecting the metadata filters.
- The results are formatted and displayed back to the user in the Streamlit interface.

## Streamlit UI Integration

The file `app.py` is dedicated to the user interface.

- It uses `st.title`, `st.write`, and `st.columns` to create the page layout.
- Interactive widgets like `st.text_input` (for the search query), `st.selectbox` (for severity), and `st.slider` (for CVSS score and number of results) are used to collect user input.
- `st.button` triggers the search operation.
- `st.spinner` provides user feedback during long operations like initialization and searching.
- The results are displayed in an organized manner using `st.expander` for each vulnerability, allowing the user to view details on demand.
- Crucially, `@st.cache_resource` is used to ensure the expensive process of loading data and initializing the search engine only happens once, making the app responsive on subsequent interactions.

## How to Run

1. **Clone the repository:**
   ```bash
   git clone https://github.com/Prosen-Ghosh/llm_demo.git
   cd vulnerability-search
   ```

2. **Create a virtual environment and activate it:**
   ```bash
   python3 -m venv vulnerability_search_env
   source vulnerability_search_env/bin/activate
   ```

3. **Install the required packages:**
   ```bash
   pip install -r requirements.txt
   ```

4. **Run the Streamlit app:**
   ```bash
   streamlit run app.py
   ```

**Note on `main.py`:**

The `main.py` script is used to fetch the latest CVE data from the NVD API and create the `cve_data.json` file. To run it, simply execute the following command:

```bash
python main.py
```

This will download the latest vulnerability data and create the necessary JSON file for the Streamlit application.

## Dependencies

- `sentence-transformers`
- `chromadb`
- `requests`
- `beautifulsoup4`
- `pandas`
- `numpy`
- `streamlit`
- `python-dotenv`

## ü§ù Contributing

Contributions are welcome! If you have suggestions for improvements or new features, please feel free to open an issue or submit a pull request.