import requests
import json
import pandas as pd
from datetime import datetime, timedelta
import os

class CVEDataLoader:
    def __init__(self, data_dir="./data"):
        self.data_dir = data_dir
        os.makedirs(self.data_dir, exist_ok=True)

    def fetch_nvd_data(self, years_back=1):
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        current_year = datetime.now().year

        cve_data = []

        for year in range(current_year - years_back, current_year + 1):
            print(f"Fetching CVEs for {year}...")
            # url = f"{base_url}?pubStartDate={year}-01-01T00:00:00:000Z&pubEndDate={year}-12-31T23:59:59:999Z"
            url = f"{base_url}?pubStartDate={year}-01-01T00:00:00.000Z&pubEndDate={year}-04-30T23:59:59.999Z"

            print(f"Requesting URL: {url}")
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                response = requests.get(url, headers=headers)
                if response.status_code == 200:
                    data = response.json()
                    print(f"Fetched {len(data.get('result', {}).get('CVE_Items', []))} CVEs for {year}")
                    cve_data.extend(self._parse_cves_v2(data))
            except Exception as e:
                print(f"Error fetching data for {year}: {e}")

        return cve_data
    
    def _parse_cves_v2(self, data):
        """Parse NVD API 2.0 JSON response"""
        parsed_cves = []
        
        if 'vulnerabilities' not in data:
            return parsed_cves
        
        for item in data['vulnerabilities']:
            cve_item = item['cve']
            cve_id = cve_item['id']
            
            # Get description
            description = ""
            for desc in cve_item['descriptions']:
                if desc['lang'] == 'en':
                    description = desc['value']
                    break
            
            # Get CVSS score if available
            cvss_score = 0.0
            severity = "UNKNOWN"
            
            if 'metrics' in cve_item:
                # Try CVSS v3 first
                if 'cvssMetricV31' in cve_item['metrics']:
                    cvss_data = cve_item['metrics']['cvssMetricV31'][0]['cvssData']
                    cvss_score = cvss_data['baseScore']
                    severity = cvss_data['baseSeverity']
                elif 'cvssMetricV30' in cve_item['metrics']:
                    cvss_data = cve_item['metrics']['cvssMetricV30'][0]['cvssData']
                    cvss_score = cvss_data['baseScore']
                    severity = cvss_data['baseSeverity']
                elif 'cvssMetricV2' in cve_item['metrics']:
                    cvss_data = cve_item['metrics']['cvssMetricV2'][0]['cvssData']
                    cvss_score = cvss_data['baseScore']
                    severity = cve_item['metrics']['cvssMetricV2'][0]['baseSeverity']
            
            # Get CWE information
            cwe_info = []
            if 'weaknesses' in cve_item:
                for weakness in cve_item['weaknesses']:
                    for desc in weakness['description']:
                        if desc['lang'] == 'en':
                            cwe_info.append(desc['value'])
            
            # Get affected products
            affected_products = []
            if 'configurations' in cve_item:
                for config in cve_item['configurations']:
                    for node in config.get('nodes', []):
                        for product in node.get('cpeMatch', []):
                            if 'criteria' in product:
                                affected_products.append(product['criteria'])
            
            parsed_cve = {
                'cve_id': cve_id,
                'description': description,
                'cvss_score': float(cvss_score) if cvss_score else 0.0,
                'severity': severity,
                'cwe_list': cwe_info,
                'affected_products': affected_products[:5],  # Limit to first 5
                'published_date': cve_item.get('published', ''),
                'last_modified': cve_item.get('lastModified', '')
            }
            parsed_cves.append(parsed_cve)
        
        return parsed_cves
    
    def load_sample_data(self):
        """Load sample CVE data for testing"""
        sample_cves = [
            {
                'cve_id': 'CVE-2021-44228',
                'description': 'Apache Log4j2 vulnerable to remote code execution when configured to use JNDI features.',
                'cvss_score': 10.0,
                'severity': 'CRITICAL',
                'cwe_list': ['CWE-502'],
                'affected_products': ['Apache/Log4j'],
                'published_date': '2021-12-10'
            },
            {
                'cve_id': 'CVE-2014-0160',
                'description': 'The Heartbleed bug allows anyone on the Internet to read the memory of systems protected by vulnerable versions of OpenSSL.',
                'cvss_score': 7.5,
                'severity': 'HIGH',
                'cwe_list': ['CWE-200'],
                'affected_products': ['OpenSSL/OpenSSL'],
                'published_date': '2014-04-07'
            },
            {
                'cve_id': 'CVE-2017-0144',
                'description': 'Windows SMB Remote Code Execution Vulnerability in Microsoft Windows.',
                'cvss_score': 8.1,
                'severity': 'HIGH',
                'cwe_list': ['CWE-119'],
                'affected_products': ['Microsoft/Windows'],
                'published_date': '2017-03-14'
            }
        ]
        return sample_cves

    def save_data(self, cve_data, filename="cve_data.json"):
        filepath = os.path.join(self.data_dir, filename)
        with open(filepath, 'w') as f:
            json.dump(cve_data, f, indent=2)
        print(f"Data saved to {filepath}")

    def load_data(self, filename="cve_data.json"):
        try:
            # Get the directory where the current script is located
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(current_dir)  # Go up one level to project root
            data_dir = os.path.join(project_root, "data")
            
            filepath = os.path.join(data_dir, filename)
            
            print(f"Looking for data file at: {filepath}")
            
            if not os.path.exists(filepath):
                print(f"Data file not found at {filepath}")
                # Try alternative locations
                alternative_paths = [
                    os.path.join(current_dir, filename),  # Same directory as script
                    os.path.join(os.getcwd(), "data", filename),  # Current working directory
                    filename  # Just the filename (for Streamlit Cloud)
                ]
                
                for alt_path in alternative_paths:
                    if os.path.exists(alt_path):
                        filepath = alt_path
                        print(f"Found data file at alternative location: {filepath}")
                        break
                else:
                    print("Data file not found in any location")
                    return []
            
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                print(f"Successfully loaded {len(data)} CVEs from {filepath}")
                return data
                
        except Exception as e:
            print(f"Error loading data: {e}")
            return []
